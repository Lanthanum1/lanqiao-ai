index,content
⾯向过程与⾯向对象的区别,⾯向过程可以理解为按步骤处理问题 ；⾯向对象可以理解为将具体事务存在的属性、⾏为抽象出来，然后去进⾏实现。
什么是值传递和引用传递,值传递是对基本数据类型而言，只进行值的拷贝，不会影响原变量 ；引⽤传递是对对象⽽⾔，不是传递对象的值，⽽是传递对象的地址，如果副本改变会影响到原对象。
String为什么是不可变的,String内部维护的是private final char/byte数组，不可变线程安全好处-防⽌被恶意篡改-作为HashMap的key可以保证不可变性-可以实现字符串常量池，在Java中，创建字符串对象的⽅式：通过字符串常量进⾏创建，在字符串常量池判断是否存在，如果存在就返回，不存在就在字符串常量池创建后返回；通过new字符串对象进⾏创建，在字符串常量池中判断是否存在，如果不存在就创建，再判断堆中是否存在，如果不存在就创建，然后返回该对象，总之要保证字符串常量池和 堆中都有该对象。
String、StringBuilder、StringBuffer的区别,String内部维护的是private final char/byte数组，不可变线程安全；StringBuilder可变，线程不安全，可以使⽤append进⾏拼接字符串；StringBuffer可变，通过synchronized来保证线程安全，操作和StringBuilder⼀样，synchronized对于出现在循环中会进⾏锁粗化，会将锁的范围扩展到整个操作，从⽽避免频繁进⾏锁操作造成性能开销。
final、finally、finalize的区别,final修饰的类不能被继承、属性是常量⽽且必须初始化、修饰的⽅法不能被重写finally⽤于异常处理，finally代码块中的内容⼀定会执⾏。finalize是Object类的⼀个⽅法，当我们调⽤system.gc()时会调⽤，也可以使用它在GC时自救⼀次。重写finalize⽅法的对象会被加⼊到⼀个unfinalized链表中，⾸次GC时不会回收该对 象，调⽤完finalize后，然后从unfinalized链表剔除，此时对象可以进⾏⾃救，将⾃⼰重新加⼊到引⽤链上，下⼀次GC时会进⾏回收。
ArrayList和LinkedList的区别,ArrayList基于数组实现，LinkedList基于链表实现ArryList适合随机查找，LinkedList适合增删，时间复杂度不同ArrayList和LinkedList都是基于List接⼝实现的，LinkedList还实现了Deque接⼝，可以当做 队列使⽤
CopyOnWriteArrayList底层实现原理,CopyOnWriteArrayList是基于数组实现的，采⽤多写分离的⽅式来应对多线程的读写操作，当对内部数组进⾏操作时，会拷⻉⼀份出来⽤于写，写操作时会进⾏加锁避免并发写⼊导致 数据丢失，⽽读依旧在旧数组进⾏，当操作完之后，再将引⽤重新指向新数组完成整个操作CopyOnWriteArrayList适合读多写少的场景，但是⽐较吃内存，并且对于实时性要求很⾼场景不太适⽤因为可能读到旧数据
HashMap在JDK 7和JDK 8的区别,HashMap在JDK 7采⽤的是 数组 + 链表 的⽅式，由于HashMap的key是基于hash值计算后放到对应的数组槽位的，可能会出现hash碰撞，所以在每个槽位采⽤链表头插法进⾏存放元 素，如果容量不⾜会先扩容HashMap在JDK 8采⽤的是 数组 + 链表/红⿊树 的⽅式，基于JDK 7的基础上为了解决链表过⻓导致查询效率降低以及头插法导致循环链表从⽽死循环造成CPU满载的问题，所以JDK8采⽤了尾插法
ConcurrentHashMap在JDK7和JDK 8的区别,在JDK 7下，采⽤分段锁的⽅式来保证线程安全，内部维护了⼀个segment数组，每个segment都包含了⼀个HashEntry数组，相当于⼀个⼩的HashMap提供了get、put⽅法，并 且segment都实现了ReentrantLock，put元素时通过ReentrantLock加锁在JDK 8下，采⽤synchronized来保证线程安全的，内部维护⼀个Node数组，put元素时对Node节点进⾏加锁，相当于JDK 7减⼩了锁的粒度并且节省了内存
线程、进程、协程的区别,进程是操作系统资源分配的最⼩单位。进程的通信⽅式：管道：管道分为匿名管道与命名管道，匿名管道⽤于⽗⼦进程通信，命名管道⽀持各种进程通信信号：信号是软件层⾯对中断机制的模拟消息队列：克服信号量有限的弊端，具有读、写能⼒共享内存：通过多个进程读取公共内存进⾏通信，⽐如分布式锁Socket：⽤于⽹络中不同机器的进程通信线程是操作系统任务调度和执⾏的最⼩单位，归属于进程。线程的通信⽅式：通过volatile来保证可⻅性，但是volatile常⽤于单写多读的场景协程是存在于⽤户态轻量级线程，通过减少上下⽂切换频率提升并发性能
线程常用方法,sleep：可以指定时间，让线程短暂休眠，通过interrupt可以打断休眠状态，如果抛出中断异常 会清除中断标志；sleep(0) 等价于 yield；yield：上下⽂切换，会让出CPU资源；join：会让join线程先执⾏，主线程暂停；join底层会⼀直检查join线程是否存活，如果存活会让其他线程继续等待；stop：stop不推荐使⽤，因为会强制终⽌未执⾏完的线程。
什么是线程中断,线程中断就是通过中断信号去告诉线程你可以停⽌，但是线程并不会⽴刻停⽌，如果收到了信号，可以⾃定义终⽌逻辑，相对于stop直接强制线程终⽌优雅很多。线程中断的⽅法：interrupt给线程加上中断标志，不会终⽌线程；interrupted判断是否有中断标志，有会清除；isInterrupted判断是否有中断标志，但不会清除。可以通过while循环判断isInterrupted和共享变量来处理中断，但是要注意如果有⽤sleep可以通过interrupt把中断标志位加上。
线程的创建⽅式有哪些,线程创建的⽅式实际只有⼀种，都是通过new Thread创建，然后通过调⽤start⽅法去内核态创建线程，完成后回调run⽅法。通常说的创建⽅式：继承Thread类，重写run⽅法；实现Runable接⼝，重写run⽅法；实现Callable接⼝，重写call⽅法，通过FutureTask创建来获取执⾏的结果；通过线程池创建。
为什么要使⽤线程池,线程的创建和销毁都需要进⾏⽤户态和内核态的切换，当new Thread时会通过start去内核态创建线程，完成后回调run⽅法，使⽤线程池可以减少切换频率；线程池的使⽤⽅便管理线程，通过复⽤线程减少性能开销，以及提⾼执⾏任务的响应速度。
线程池的类型有哪些,常⻅的线程池SingleThreadPool核⼼线程与⾮核⼼线程数为1，⾮核⼼线程存活时间为0，采⽤LinkedBlockingQueue作为阻塞队列，⽐较适合单线程串⾏任务；FixedThreadPool核⼼线程与⾮核⼼线程数为n，⾮核⼼线程存活时间为0，采⽤LinkedBlockingQueue作为阻塞队列，⽐较适合CPU密集型任务；CachedThreadPool核⼼线程数为0，⾮核⼼线程数为n，⾮核⼼线程存活时间为60s，采⽤SynchronousQueue作为阻塞队列，⽐较适合传递性任务；ScheduledThreadPool⽤来定期执⾏任务。
ThreadLocal实现原理,ThreadLocal主要是保存线程变量副本的，⼀般可以⽤来缓存⽤户信息、连接等，通过保证每个线程变量隔离来实现线程安全。ThreadLocal会对线程维护⼀个以ThreadLocal作为Key的Map(ThreadLocalMap)，Value对应的是当前线程变量的副本，Key是弱引⽤所以GC时会回收，但是Value是强引⽤，所以如果不⼿动清除，Value会⼀直霸占⽼年代空间导致内存泄露(ML)。对于ThreadLocal只能保证线程内部的通信，如果想要进⾏⽗⼦线程通信，可以使⽤InheritableThreadLocal，它实现原理是⽗线程在创建⼦线程时会将当前的变量副本拷⻉⼀份给⼦线程，但是InheritableThreadLocal遇到线程池就不能完成⽗⼦通信了，因为线程池⼀旦创建完线程就会进⾏复⽤，所以可以使⽤TransmittableThreadLocal，它实现原理就是在线程池中不管线程是否是新建都会在调⽤时抓取⽗线程的上下⽂给⼦线程。另外ThreadLocal内部ThreadLocalMap使⽤线性探测法实现的哈希表，所以⾯临⼤量线程绑定数据时性能较低，所以Netty引出了FastThreadLocal，底层直接通过更⼤数组空间的开辟，通过数组索引进⾏定位，避免线性探测，采⽤空间换时间，并且FastThreadLocal在任务执⾏完之后会对Value清除避免内存泄露。哈希冲突的解决⽅法：拉链法、红⿊树、线性探测法，即寻找最靠近的下⼀个空槽。
乐观锁和悲观锁的区别,乐观锁：就是每次拿数据时认为别⼈不会修改，所以不会加锁，但是修改数据时会判断有没有⼈去修改这条数据，⼀般情况下乐观锁会配合版本机制⼀起，⽐如AtomicStampedReference，主要是为了避免ABA问题，就是当多个线程去修改共享变量时，某个线程将共享变量从A修改到B，⼜⽴即修改为A，但是其它线程并没有感知到，依旧修改成了B；悲观锁：就是每次拿数据时认为别⼈⼀定为修改，所以会加锁，下个⼈想来操作必须等待前⾯的⼈释放锁，⽐如synchronzied。
常⻅的原⼦类,对于多线程操作变量⾃增的场景，我们可以使⽤AtomicInteger、AtomicLong，它们内部维护了⼀个共享资源state，通过⾃旋CAS来维护state，但是当线程过多时，会导致CPU满载， 所以应对这个问题可以采⽤分散热点的⽅式将热点值分散出去，所以引出了LongAddr，它 通过将共享资源分散到Cells数组的各个槽位，每个线程针对⾃⼰的槽位进⾏CAS操作即可， 最终只要将各个槽位的值累加起来就是结果了，但是它不能实时获取值，另外JUC下还提供 了LongAccumulator实现本质⼀样，可以进⾏⾃定义计算过程，对于CAS操作都会存在ABA问题，如果想处理该问题可以使⽤AtomicStampedReference，它每次修改时都会⽤stamped版 本号进⾏判断。
Java死锁如何避免,避免使⽤嵌套锁，保证按顺序获取锁，并且锁设置超时时间以及注意死锁的检查，能在第⼀时间处理。
什么是CAS,CAS属于乐观锁，就是将预期值与内存中的值进⾏⽐较，如果相等就修改，同样的与乐观锁⼀样会出现ABA问题，所以会配合版本机制⼀起使⽤。ABA问题就是当多个线程去修改共享变量时，某个线程将共享变量从A修改到B，⼜⽴即修改为A，但是其它线程并没有感知到，依旧修改成了B，对于解决ABA问题，可以参考AtomicStampedReference，每次写时都会⽤stamped版本 号进⾏判断，或者MySQL中的乐观锁实现，表中额外维护⼀个版本号version，每次修改时去判断⼀下。为了保证数据能写成功，CAS会配合⾃旋⼀起使⽤，所以当线程过多时，会导致CPU满载，为了避免这个问题，可以参考synchronized的⾃适应⾃旋，⾃旋⼀定时间之后阻塞。CAS从源码层⾯看，主要是通过并发的三⼤特性来考虑的：原⼦性：多个操作要么全部执⾏成功，要么全部执⾏失败。CAS的原⼦性在单核处理器下依赖cmpxchgl指令保证，⽽在多核处理器下需要配合lock前缀修饰才能保证，也就是lock cmpxchgl，lock前缀的三个特性：保证后续指令的原⼦性；缓存⾏锁定，线程去修改⾃⼰本地的变量副本时，会通过缓存⾏锁定将新值刷回主存；触发MESI协议，可以有效的解决可⻅性问题基于写失效的缓存⼀致性协议。有序性：通过C++的volatile关键字保证的，它具备禁⽌重排序以及防⽌代码被优化的功能。可见性：基于lock前缀保证的，但是JUC包下的原⼦类不能保证get和set原⼦性，需要通过volatile修饰共享资源state来保证可见性。
谈⼀下synchronized,synchronized是Java的内置锁，属于悲观锁，悲观锁就是每次读写的时候都会加锁，想要⽤必须等待前⾯的线程解锁。在JDK 6之前是基于Monitor机制实现的，依赖于底层互斥原语Mutex，属于重量级锁，性能较低；在JDK 6之后迫于JUC包的压⼒，对synchronzied进⾏了优化，引⼊了偏向锁、轻量级锁等机制，synchronized为了避免直接从⽤户态切换到内核态park线程，所以在单⼀线程的情况下默认开启偏向锁，在线程交替执⾏的时候会使⽤轻量级锁，偏向锁和轻量级锁 操作都是基于⽤户态的对象MarkWord，也就表示这两种情况下加解锁不需要切换到内 核态，性能⼏乎⽆损耗，如果竞争相对激烈，轻量级锁优先采⽤⾃适应⾃旋来避免park，如果实在不⾏，才会启动重量级锁，park让Mutex互斥量来进⾏，如今性能基本与JUC持平。synchronized的⽤法：对类对象加锁：synchronized(A.class) synchronized static a()对类实例对象加锁：synchronized(this) synchronized(obj)synchonirzd如何保证并发的三⼤特性的：原⼦性：原⼦性是通过加锁和释放锁保证的；有序性、可⻅性：通过在加锁和解锁过程中使⽤内存屏障来确保共享变量的变化对所有线程都是可⻅的以及防⽌指令重排序。加锁：load屏障 + acquire屏障；解锁：store屏障 + release屏障从字节码层⾯看synchronized：同步代码块：通过monitorenter和两个monitorexit实现的，对于第⼀个monitorexit处理正常返 回，第⼆个monitorexit处理异常情况⾃动释放锁，所以synchronized不像Lock那样 需要⾃⼰释放锁，不过也可以通过Unsafe类去⼿动控制synchronized，但是不推荐。synchronized的可重⼊的实现：synchronized会维护⼀个计数器，当monitorenter时计数器 +1，monitorexit时计数器 -1。同步⽅法：通过acc_synchronized访问标志实现。
什么是AQS,AQS(AbstractQueuedSynchronizer)是JUC包下的线程同步框架，JUC包下的许多⼯具都是基 于AQS实现的，内部维护了⼀个volatile修饰的共享变量state和⼀个双向链表的同步队列， state可⽤作锁标识，没有抢到锁的线程就会被安排进⼊同步队列中等待，对于可重⼊性， 可以对state进⾏加减来记录重⼊次数。
谈⼀下Java的共享内存模型JMM,JMM为了屏蔽各种硬件和系统差异来实现Java并发以及告诉我们如何实现线程通信主要围 绕并发的三⼤特性展开的。对于多线程操作共享资源的流程：线程从主存将共享资源读(read)出来，然后加载(load)到⾃⼰本地内存赋值给变量副本，然后线程会使⽤(use)这个变量副本进⾏操作，当先需要修改共享资源的时候，首先会分配(assign)新值给变量副本，然后将新值刷(store)到主存中，最后回写(write)赋值给主存中的共享资源。从操作流程上，其他线程并不能⽴刻感知到共享资源的变化，需要等到某个时间点才能发⽣，⽐如上下⽂切换，所以JMM并不能保证共享资源的实时性，所以需要基于写失效的缓存⼀致性协议MESI来保证实时可⻅性。MESI协议，M代表已修改、E代表独占、S代表共享、I代表失效主存中维护了共享资源。线程A将共享资源读(read)出来，然后加载(load)到⾃⼰本地内存中赋值给变量副本，此时处于独占状态，线程A会使⽤(use)这个变量副本进⾏操作，当线程B也去操作这个共享资源时，此时处于共享状态；当线程A想去修改共享资源时，会将新值分配(assign)给⾃⼰本地内存的变量副本， 然后处于已修改状态，然后刷(store)到主存中，最后回写(write)赋值给主存中的共享资源，此时线程B感知到共享资源变化了，然后将⾃⼰的变量副本失效，处于失效状态。
什么是双亲委派机制,双亲委派机制是⼀个⾃上⽽下的类加载过程，⾸先会委托⽗加载器去加载⽬标类，如果能 找到⽬标类就加载，如果找不到就继续委托它的⽗加载器去加载，如果⽗加载器都加载不 了，就⾃⼰去加载
Tomcat为什么要打破双亲委派机制,从隔离性上讲，相同类库的不同版本需要进⾏隔离防⽌冲突，另外Tomcat⾃⼰的类库也需要隔离；从共享性上讲，保证相同版本之间类库可以进⾏共享，避免重复加载的性能开销 从热部署上讲，每个jsp对应⼀个类加载器，⽅便实现热部署：实现热部署的⽅式可以开启⼀个后台线程实时监听指定路径下jsp⽂件的变动，如果有变动就会将原先的类加载器置为null，等待GC去回收，然后使⽤新的类加载器去加载。
JVM的重要组成部分和作⽤,JVM的组成部分主要分为两个⼦系统和两个组件，两个⼦系统就是类加载⼦系统和字节码执⾏引擎，类加载⼦系统主要是负责将字节码⽂件加载到JVM内存中去，字节码执⾏引擎 主要是负责GC、执⾏字节码⽂件中的指令以及修改程序计数器中的值等。两个组件就是本地接⼝和运⾏时数据区，本地接⼝主要是与本地库打交道，都知道JVM是C++写的，所以需要⼀些本地库的⽀持。运⾏时数据区就是我们常说的JVM内存，主要分为线程共享和线程独享两⼤块线程共享，有堆和⽅法区：⼀般new出来的对象都会存放在堆中，⽅法区(元空间)在JDK 7时处于堆中，在JDK 8中，⽅法区叫元空间，从堆中移除⽽放到直接内存中，主要是因为直接内存对IO操作具有更⾼的性能 并且减少中间步骤的开销(虚拟内存到直接内存的重复开销)。线程独享有栈、本地⽅法栈和程序计数器，栈：栈主要是存放栈帧的，⼀个⽅法对应⼀个栈帧，栈帧主要分为局部 变量表、操作数栈、⽅法出⼝、动态链接。局部变量表类似于⼀个table，存放编译期间的变量或对象的内存地址，在编译期间，this会作为隐式参数放在局部变量表的第⼀位操作数栈；操作数栈主要是⽤来进⾏⼀些操作数运算，运算完之后再赋值到局部变量表；⽅法出⼝就是通过它进⾏定位⽅法被调⽤的位置动态链接；动态链接就是引⽤类型变量与堆中实际对象的关联关系，主要是⽤来定位堆中实际对象的；本地⽅法栈与栈基本⼀致，只不过是⽤来处理本地⽅法；程序计数器相当于代码执⾏位置的标识。整体流程就是类加载⼦系统会将字节码⽂件加载到JVM内存中，⽽字节码⽂件不能直接被操作系统识别，所以需要通过字节码执⾏引擎去解析成操作系统能识别的指令，然后将指令交给CPU去执⾏，⽽这个过程需要本地接⼝与本地库的交互。
对象的创建过程,对象的创建过程是类加载检查、分配内存、初始化零值、设置对象头、执⾏<init>⽅法。类加载检查就是当JVM遇到⼀个new指令时，会先检查这个类的符号引⽤在不在常量翅中，如果能找到就会进⾏类加载检查，如果没有就会进⾏类加载过程；分配内存就是经过类加载检查之后，对象占⽤的内存也能确定下来，会在堆上划分⼀块内存空间给对象使⽤，划分内存的⽅式主要有指针碰撞和空闲列表：指针碰撞就是针对于内存规整的情况⽽⾔的，会将⽤过的内存和空闲的内存⽤指针中间⽤指针隔开，当需要分配内存时，只要将指针往空闲区域 移动就⾏；空闲列表就是针对于内存不规整的情况⽽⾔的，会⽤⼀个列表记录空闲的内存地址，当需要分配内存时，会从列表中找⼀块能存下的，然后更新列表记录。JVM⼀般情况下采⽤CAS +失败重试进⾏分配内存，为了避免并发分配竞争问题，每个线程在JVM启动时都会在Eden区分配⼀块TLAB内存(线程本地分配缓冲)⽤于分配内存，如果TLAB内存不⾜只能在Eden区进⾏分配；初始化零值就是当对象分配内存之后，会给分配到的内存空间赋零值；设置对象头就是对对象头设置相关参数，对象的布局主要有对象头、实例数据和对⻬填充，对象头的布局主要有MarkWord、Klass Pointer、数组⻓度，MarkWord 主要是存放运⾏时数据，⽐如hash、GC分代年龄等，32位占⽤4字节，64位占⽤8字节Klass Pointer 就是指向类元数据信息的指针，32位战友4字节，64位占⽤8字节，开启指针压缩占⽤4字节；数组⻓度是只有数组对象才会有，占⽤4字节实例数据 就是存放类的属性信息；对⻬填充就是保证对象占⽤空间位8的倍数，通过内存对⻬填充后，CPU 的内存访问效率会⼤⼤提升以及规避操作系统之间的差异。通过对象的布局可以计算出Object对象占⽤16字节：calc = (Mark Word-64位) + (Klass Pointer + 开启指针压缩) + 对⻬填充 = 8 byte + 4 byte + 4byte = 16 bytecalc = (Mark Word-64位) + (Klass Pointer + 关闭指针压缩) = 8 byte + 8 byte = 16 byte执⾏<init>⽅法：设置完对象头之后，会执⾏<init>⽅法按照预期值对内存空间进⾏初始化，然后执⾏构造⽅法。
垃圾收集算法有哪些,标记复制算法就是将内存分为⼤⼩相等的两块，⼀块⽤来存，⼀块空着。当进⾏GC时，将存活的对象移到空的那块，清空⽤过的那块，标记复制算法⽐较浪费内存，⼀般⽤在年轻代标记清除算法。标记清除算法就是标记出⾮垃圾对象，清除未标记的对象。标记清除算法当内存空间较⼤时，标记会⾮常耗时，并且会出现⼤量内存碎⽚，⼀般⽤在⽼年代标记整理算法。标记整理算法就是将存活的对象存放在⼀端，清除端以外的对象。标记整理算法可以解决内存碎⽚的问题，但是会涉及⼤量对象的移动，⼀般⽤在⽼年代。分代理论就是根据不同分代的特点选择合适的垃圾收集器。
什么是STW,STW 就是stop the world，会暂停所有⽤户线程来进⾏GC，对于暂停的时间与垃圾收集器有关：年轻代的Minor GC(Young GC) ⼏乎⽆感觉，⽼年代的Full GC可能会感觉到卡顿⼀下。
引⽤类型有哪⼏种,强引⽤：⼀般new出来的对象就是强引⽤，即使内存不⾜，GC都不会回收；软引⽤：通过SoftReference包装的类，在内存溢出(OOM)前会被回收，可以⽤作⾼速缓存使⽤；弱引⽤：通过WeakRefrence包装的，⽆论内存是否充⾜，GC都会回收；虚引⽤：幽灵引⽤⼀般不使⽤。
JVM如何处理跨代引⽤,跨代引⽤处理涉及到卡⻚和卡表的概念：卡⻚，JVM将⽼年代堆分成以512kb的⼀块块内存空间，每块内存会存很多对象；卡表，JVM会在年轻代的Eden区维护⼀个bitmap，⽤来记录卡⻚是否存在跨代引⽤，倘若1号卡⻚存在跨代引⽤，那么就会将bimap的偏移量为1的位置设置为1，表示存在跨代 引⽤关系，此时会将1号卡⻚的所有对象加⼊到GC Root的扫描范围中去。
JVM故障分析,对于还在正常运⾏的系统，可以使⽤jmap去查看JVM中各个区域的使⽤情况，假如有内存激增的情况，可以定位到哪个地⽅对象创建⽐较多，可以使⽤jstack去查看线程的运⾏情况，⽐如有哪些线程阻塞、是否产⽣了死锁可以使⽤jstat查看垃圾回收的情况，假如Full GC⽐较频繁，就得进⾏G调优了。对于各个命令的结果，可以直接通过jvisualvm⼯具查看分析，观察Full GC的频率，如果Full GC频繁但是没有出现OOM，那么表示Full GC实际上回收了很多对象，所以这些对象最好是能在MinorGC的时候进⾏回收，避免直接进⼊⽼年代，对于这种情况，要考虑存活时间不⻓的对象是不是⼤对象，对于⼤对象尽早的让它们进⼊⽼年代，避免由于复制算法带来的性能问题，尝试加⼤年轻代的⼤⼩，让朝⽣夕死的对象在Minor GC的时候被回收，如果Full GC减少，说明调优有效，同时观察占⽤CPU最多的线程，定位具体的⽅法，优化这个⽅法的执⾏，看是否能避免某些对象的过多创建，从⽽节省内存。对于已经发⽣OOM的系统，⼀般⽣产系统中都会配置发⽣OOM的时候⽣成dump⽂件，我们可以通过jvisualvm进⾏分析，找出dump⽂件异常的地⽅⽐如异常的线程、对象，定位到具体的代码位置，然后进⾏详细分析。
内存溢出和内存泄露的区别,内存溢出(OOM)：内存泄露达到⼀定程度会导致内存溢出，但是内存溢出也可能是⼤对象导致的；内存泄露(ML)：对象⽆法得到及时回收，到最后持续占⽤内存空间，造成内存空间的浪费，内存泄露，⼀般是强引⽤才会出现问题。
Redis为什么这么快,基于内存的读写操作，没有磁盘IO的性能开销；采⽤单线程去处理⽹络IO请求以及指令的执⾏，避免多线程的竞争以及上下⽂切换的 开销；采⽤IO多路复⽤epoll机制，让单线程去处理多个请求，当有操作时会⽴刻通知去处理； 对于每种数据类型都进⾏了优化，⽐如使⽤ziplist来节省空间以及skiplist来提升查找1效率。
什么是IO多路复⽤,IO多路复⽤是⼀种同步IO模型，允许单线程去同时监听多个⽂件描述符，⼀旦⽂件描述符就绪就会通知程序去处理，常⻅的有select、poll、epoll。select基于数组实现，每次调⽤都进⾏遍历，最⼤连接数有上限；poll通过链表实现，每次调⽤都进⾏遍历，最⼤连接数⽆上限；epoll通过哈希表实现，通过事件通知，每当有IO事件就绪，系统注册的回调函数 就会被调⽤，最⼤连接数⽆上限。在选择三者上需要根据实际场景进⾏选择，表⾯上看epoll性能最好，但是如果在连接数少并且活跃度较低时，select和poll的性能最好，低效的原因主要在轮询遍历上，所以也得视情况看。
Redis的Reactor模型,Reactor模型有三种：单线程模式：⼀个线程负责多个事件处理，当连接数过多时会造成性能瓶颈，适⽤于连接数较少、复杂度较低的场景；多线程模式(单线程、⼯作线程池)：在单线程Reactor模式的基础上，将业务处理部分交给了线程池，提升并发能⼒， 但是要注意线程安全；主从多线程模式：将整体拆分为主、从Reactor，主Reactor负责监听连接事件，将事件分发给从Reactor去处理，从Reactor负责与客户端读写操作，充分利⽤多核CPU，提升并发能⼒；Redis采⽤的是单线程模式。
Redis怎么实现⾼可⽤,主从模式主要是采⽤了读写分离的⽅式，主节点负责读写，从节点负责读，如果主节点挂了，需要⼈⼯去将从节点晋升为主节点，同时还要告知应⽤⽅。主从复制过程：从节点每次都会向主节点发送pysnc同步指令，主节点对于⾸次连接，会开启bgsave⼦线程将内存中的全量数据⽣成rdb⽂件，在持久化过程中，如果从节点有新的写命令会缓存下来，当持久化结束之后，主节点会将rdb⽂件同步给每个从节点，如果同步期间存在⽹络波动，从节点会进⾏重连，恢复之后会继续同步。主从复制是异步的，存在主从数据不⼀致的问题，所以要保证⽹络畅通、监控主从复制情况以及使⽤数据过期策略。⽹络波动导致从节点同步数据过慢，从节点执⾏阻塞的命令导致数据获取不⼀致，由于⼀主多从会导致主节点压⼒过⼤(主从复制⻛暴)，所以可以考虑主-从-从形式将压⼒分摊出去。哨兵模式：主从模式不能进⾏故障转移⼯作，需要⼈⼯将从节点晋升为主节点，所以引出了哨兵模式，哨兵不进⾏读写，只负责监控、通知以及选主。哨兵选主过程：在运⾏期间，每个哨兵节点每秒都会ping下主节点，如果ping不通，主节点就会被标记为主观下线，如果过半以上的哨兵节点，都认为主节点主观下线，那么主节点就会被标记为客观下线，每个发现主节点客观下线的哨兵节点，都会优先推选⾃⼰去进⾏故障转移，⽽超过⼀半以上选票的哨兵，最终会去负责主从切换的⼯作。Redis Cluster集群模式：哨兵模式在进⾏故障转移的过程中可能因为⽹络问题导致⽆法选主，并且只有⼀个主节点⽆法实现⾼并发，所以引出了Redis Cluster集群模式。Redis Cluster集群模式是由多主多从组成的，⾄少要满⾜ 2N+1 个主节点(过半选举机制)，可以⾃我选主以及故障转移⼯作，Redis Cluster会将数据分散到16384各槽位中，每个节点管理⼀部分数据，当客户端连接集群时，会缓存槽位信息⽤来定位⽬标节点，并且会有定位纠错机制，当发现定位异 常时，会进⾏重定位，并且将槽位信息重新缓存⼀份，集群节点之间的通信是采⽤的gossip协议，由于数据是分散存储的，时效性较弱，Redis Cluster集群模式存在数据倾斜问题，可以采⽤本地缓存、对key进⾏分⽚处理或对⼤key进⾏拆分Redis Cluster集群主从选举过程：当从节点发现主节点挂了，会优先推选⾃⼰，然后告知剩余存活的主节点希望得到⽀持，当某个从节点收到过半以上主节点的反馈之后，就会成为新的主节点，然后告知集群的其它节点，可能会出现两个从节点得到的票数⼀致，此时只要错开时间重新选举即可。
常⻅的IO模型,常⻅的IO模型有BIO、NIO、AIO、IO复⽤；BIO 就是常规的IO操作，同步阻塞，适合少请求的场景；NIO 就是单线程能处理多个请求，当有事件发⽣会通知去处理，同步⾮阻塞，适合⼤量并发请求的场景；AIO 就是NIO的升级版，通过操作系统的回调通知去让线程处理事件，异步⾮阻塞，适合超⼤并发请求的场景；IO复⽤就是基于select、poll、epoll机制去实现，适合⼤量并发连接的场景：select基于数组实现，每次调⽤都进⾏遍历，最⼤连接数有上限；poll通过链表实现，每次调⽤都进⾏遍历，最⼤连接数⽆上限；epoll通过哈希表实现，通过事件通知，每当有IO事件就绪，系统注册的回调函数 就会被调⽤，最⼤连接数⽆上限。在选择三者上需要根据实际场景进⾏选择，表⾯上看epoll性能最好，但是如果在 连接数少并且活跃度较低时，select和poll的性能最好，低效的原因主要在轮询遍历上，所以也得视情况看。
Netty有哪些核⼼组件,Channel 主要负责⽹络操作，⽐如连接、IO读写操作Bootstrap/ServerBootstrap 分别是客户端启动类、服务端启动类EventLoop 配合Channel处理IO操作ChannelHandler 主要负责处理各种事件，⽐如数据处理ChannelPipeline 相当于存放ChannelHandler的容器，每个Channel会绑定⼀个	ByteBuf 是Netty⾃⼰字节容器，⽤于⽹络数据读写
Netty中提供了哪些线程模型,对于线程模型，Netty是基于Reactor模型实现的，Reactor模型分为单线程模式、多线程模式以及主从多线程模式，单线程模式就是⼀个线程负责多个事件处理，多线程模式就是基于线程池的⽅式，复⽤线程处理事件，主从多线程模式就是分为主、从两个，主负责监听以及分发事件，从负责处理事件。在Netty中提供了Reator的单线程模式和多线程模式，对于IO操作都是交给EventLoop线程完成，然后通过EventLoopGroup去管理EventLoop线程来实现资源复⽤。
Zookeeper的节点类型,持久节点就是数据会被持久化下来；持久顺序节点就是基于持久节点的基础上，增加了有序；临时节点就是数据不会被持久化下来；临时顺序节点就是基于临时节点的基础上，增加了有序；容器节点就是可以有很多⼦⼦节点，但是如果没⼦节点，会定时检查去删除；TTL 就是带过期时间的节点。
Zookeeper分布式锁实现,Zookeeper的分布式锁实现可以分为⾮公平锁和公平锁，因为基于CP机制，所以适合并发不⾼的场景。⾮公平锁就是多个线程同时去竞争创建临时节点，未竞争到的线程都会去监听那个临时节点，⼀旦节点被删除，那些线程⼜都会去竞争，⾮公平锁出现惊群效应，也就是同⼀时间⼤量请求去竞争，导致服务压⼒突增；公平锁就是先会去创建⼀个容器节点，需要获取锁的线程会去这个容器节点下创建临时顺序节点，每个节点都会去监听它前⾯的兄弟节点，⼀旦线程释放锁，会按照节点创建顺序选择下⼀个节点去获取锁，保证公平性；容器节点会定期检查有⽆⼦节点，如果没有会删除，可以有效避免⼿动删除的操作。
谈⼀下ZAB协议(原⼦⼴播协议),ZAB协议是Paxos算法的⼀种简化实现，包括消息⼴播和崩溃恢复两种模式，消息⼴播就是类似于2PC过程，主节点接收数据，然后⼴播给从节点，并等待所有从节点的反馈后再统⼀提交；崩溃恢复就是在执⾏过程中发⽣了故障(⽐如从节点没反馈就挂了、主节点提交了但是从节点没提交)，能确保数据的⼀致性，ZAB的过半选举机制，通过最新zxid来确保新主节点有相对最新的数据。
ZAB和Paxos算法的联系与区别,相同点：存在类似于2PC的操作，主节点负责写，由主节点协调其它从节点运⾏ 主节点会等待过半以上从节点反馈之后，再进⾏提案提交，每个提案中都包含⼀个周期值；不同点：ZAB是⽤来构建⾼可⽤分布式主备系统的Paxos是⽤来构建分布式⼀致性状态机系统的。
谈⼀下IOC的理解,IOC主要涉及三个部分，分别是IOC容器、控制反转以及依赖注⼊。IOC容器：Spring会通过包扫描将相关的Bean注册成BeanDefinition存放BeanDefinitionMap， 当需要获取对象的时候，会通过这个Map拿出指定Bean的BeanDefinition通过反射去创建返回；控制反转：对象创建由主动创建变为了被动创建，全部交给了BeanFactory统⼀创建；依赖注⼊：IOC容器会将对象的依赖关系进⾏依赖动态注⼊，也就是有依赖关系的属性初始化 前进⾏赋值。
ApplicationContext和BeanFactory的区别,BeanFactory是Spring中⾮常核⼼的组件，专⻔⽤来⽣成Bean、管理Bean的ApplicationContext继承于BeanFactory，所以具有BeanFactory所有功能，并ApplicationContext还集成了⽐如EnvironmentCapable、MessageSource、ApplicationEventPublisher等接⼝，从⽽具备了获取系统环境变量、国际化、时间发布等功能。
谈⼀下Spring启动,Spring启动我们可以通过AnnotationConfigApplicationContext来进⾏跟踪通过调⽤AnnotationConfigApplicationContext的构造⽅法进⾏初始化reader和scanner通过scan扫描指定包路径下的class⽂件并注册成BeanDefinition放到BeanDefinitionMap 中调⽤核⼼⽅法refresh进⾏刷新容器prepareRefresh进⾏刷新前准备obtainFreshBeanFactory进⾏获取容器刷新时的Bean⼯⼚prepareBeanFactory进⾏Bean⼯⼚的初始化预处理postProcessBeanFactory进⾏处理⼦类重写该⽅法的逻辑，对Bean⼯⼚进⼀步处理	invokeBeanFactoryPostProcessors进⾏执⾏Bean⼯⼚后置处理器	registerBeanPostProcessors进⾏注册Bean后置处理器initMessageSource进⾏初始化国际化initAppplicationEventMulticaster进⾏初始化事件⼴播器onRefresh进⾏⼦类重写该⽅法，留给⼦容器registerListeners进⾏注册监听器finishBeanFactoryInitialization完成Bean⼯⼚初始化finishRefresh结束容器刷新
什么是bean的⾃动装配,在Spring框架中，在配置⽂件中设定Bean的依赖关系是⼀个很好的机制，Spring 容器能够⾃动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean⼯⼚⾃动处理Bean之间的协作，这意味着 Spring可以通过向BeanFactory中注⼊的⽅式⾃动搞定Bean之间的依赖关系，⾃动装配可以设置在每个Bean上，也可以设定在特定的Bean上。
谈⼀下Bean的⽣命周期,启动容器ApplicationContext ；创建BeanFactory；初始化BeanFactory ；BeanFactory后置处理：此时会通过将指定包路径下的class⽂件封装成Resource对象，然后遍历Resource对象，通过MetadataReaderFactory去解析Resource对象得到对应的MetadataReader，MetadataReader包含了类元数据信息、接⼝信息、注解信息等；通过MetadataReader去判断类是否能标识为Bean的注解信息以及是否有条件注解，如果有@Component注解就被归到includerFilter，如果加了@Conditional注解就得进⾏match匹配，匹配通过才算includerFilter，否则就属于excludeFilter，对于所有includerFilter都会⽣成ScannedGenericBeanDefinition，然后再基于MetadataReader去判断是否是独⽴的类，如果是筛选都通过，就会将ScannedGenericBeanDefinition放⼊集合中；⽣成BeanDefinition；合并BeanDefinition：如果BeanDefinition有⽗BeanDeifinition，会将子BeanDefinition中没有的属性从⽗，BeanDeifinition复制过来重新⽣成⼀个新的BeanDeifinition为RootBeanDefinition；加载类：通过对应的类加载器去加载BeanDefinition中的beanClass，如果是beanClass是Class类型就进⾏类加载，反之不加载；实例化前：会调⽤扩展点InstantationAwareBeanPostProcess#prostProcessBeforeInstantation，这⾥返回的对象只会经历初始化前的⽣命周期，只会进⾏初始化这⼀步 ；实例化：会判断是否通过Supplier创建对象，如果有就创建返回，⽽创建对象有两种⽅式，分别 是FactoryBean和FactoryMethod，⽽@Bean注解的⽅式属于FactoryBean，如果加了static属于FactoryMethod；推断构造⽅法：如果类中只有⼀个⽆参构造就使⽤⽆参的进⾏实例化，如果类中存在多个构造：如果有⽆参构造，依然使⽤⽆参构造如果没有⽆参构造，就会报错；如果没有⽆参但是通过@Autowired指定了某个构造，那么Spring就会先根据⽅法参数去单例池中找Bean，⾸先先通过参数类型去找，如果找到⼀个就进⾏赋值返回，如果找到多个，就会根据参数名去找，如果找到⼀个就进⾏赋值返回如果依然找到多个就会报错；BeanDefinition后置处理：会调⽤扩展点MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition，可以在这⾥对BeanDefinition进⾏加⼯；实例化后：会调⽤扩展点InstantationAwareBeanPostProcessor#postProcessAfterInstantation；⾃动注⼊；填充属性：会对@Autowired、@Resource、@Value进⾏处理，主要是通过InstantationAwareBeanPostProcessor#postProcessProperties完成的填充属性，我们也 可以⾃定义；执⾏Aware接⼝：提供了⼀些回调接⼝，⽐如BeanNameAware、ClassLoaderAware、BeanFactoryAware 给我们使⽤；初始化前：会调⽤扩展点BeanPostProcessor#postProcessBeforeInitialization 处理@PostConstruct逻辑，执⾏其他回调接⼝，⽐如EnvirnmentAware ；初始化：会调⽤扩展点InitializationBean#afterPropertiesSet ；初始化后：会调⽤扩展点BeanPostProcessor#postProcessAfterInitialization以及AOP的处理。
谈⼀下依赖注⼊流程,依赖注⼊流程主要分为两种：@Autowired注解的⽅法和@Autowired注解的属性，⾸先会根据注⼊点去找Bean，如果注解了的是属性，会先根据属性的类型去找Bean，如果注解的是⽅法，会先根据⽅法参数的类型去找Bean，如果找到了单个Bean就会直接赋值返回，如果找到了多个Bean，会从多个Bean中确定⼀个Bean，会先判断是否是isAutowiredCandidate再判断是否配合了@Qulifier，如果能确定就返回，如果加了@Primary，就返回加了这个注解的Bean，如果没有加@Primary，就会取优先级最⾼的Bean，如果以上还不能确定，就根据名字筛选，如果注解了的是属性，会通过属性名去确定⼀个Bean，如果注解了的是⽅法，会通过参数名去确定⼀个Bean，如果根据名字不能找到唯⼀的Bean就会再看@Autowired的required是否为true，如果是true就报错，如果是false就返回。
事务传播⾏为,PROPAGATION_REQUIRED，默认传播⾏为，如果当前不存在事务就创建新事务，否则就加⼊当前事务；PROPAGATION_SUPPORTS，如果当前不存在事务就以⾮事务运⾏，否则就加⼊前事务；PROPAGATION_MANDATORY，如果当前不存在事务就报错，否则就加⼊前事务；PROPAGATION_REQUIRES_NEW，每次都会创建新事务；PROPAGATION_NOT_SUPPORTED，如果当前存在事务，就将当前事务挂起，否则以⾮事务运⾏；PROPAGATION_NEVER，如果当前存在事务就报错，否则以⾮事务运⾏；PROPAGATION_NESTED，如果当前存在事务，就嵌套事务内运⾏，如果不存在事务就按照PROPAGATION_REQUIRED运⾏；
循环依赖如何解决,循环依赖就是多个对象之间存在属性相互依赖的问题，也就是先有鸡还是先有蛋的问题如何解决循环依赖问题：可以通过@Lazy注解解决构造⽅法造成的循环依赖问题；可以使⽤Spring提供的三级缓存来解决。三级缓存：⼀级缓存singletonObjects，⽤来存放完整⽣命周期的对象；⼆级缓存earlySingletonObjects，⽤来存放半成品对象，也就是初始化的对象；三级缓存singletonFactories，⽤来存放ObjectFactroy，根据不同的情况创建对象。对于处理对象之间普通的循环依赖，可以先将new出来的不完整对象放到⼆级缓存中，当其中⼀个循环依赖的对象完成⽣命周期放⼊⼀级缓存之后，由于放⼊缓存中对象存在引⽤关系，不完整的对象也完整了，然后另外⼀个对象也能正常⾛完⽣命周期了。对于处理对象之间有AOP的循环依赖，⼀级缓存和⼆级缓存就完全不够了，三级缓存会保存对象的代理配置信息，当发现产⽣循环依赖就会通过ObjectFactory进⾏创建动态代理类，提前进⾏AOP，相应的⼀级缓存存放的是⼀个代理对象。核⼼代码位置DefaultSingletonBeanRegistry#getSingleton。
Spring中的设计模式有哪些,简单⼯⼚：由⼀个⼯⼚类根据传⼊的参数，动态决定应该创建哪个实例，Spring中的BeanFactory就是简单⼯⼚模式的体现，根据传⼊⼀个唯⼀的标识来获得Bean对象，但是否是在传⼊参数后创建还是传⼊参数前创建这个要根据具体情况来定。⼯⼚⽅法：实现了FactoryBean接⼝的bean是⼀类叫做factory的bean，spring会在使⽤getBean()调⽤获得该bean时，会⾃动调⽤该bean的getObject()⽅法，所以返回的不是factory这个bean，⽽是这个bean.getOjbect()⽅法的返回值。单例模式：保证⼀个类仅有⼀个实例，并提供⼀个访问它的全局访问点，Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory，但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。适配器模式：Spring定义了⼀个适配接⼝，使得每⼀种Controller有⼀种对应的适配器实现类，让适配器代替controller执⾏相应的⽅法，这样在扩展Controller时，只需要增加⼀个适配器类就完成了SpringMVC的扩展了。装饰器模式：动态地给⼀个对象添加⼀些额外的职责。就增加功能来说，Decorator模式相⽐⽣成⼦类更为灵活，Spring中⽤到的包装器模式在类名上有两种表现：⼀种是类名中含有Wrapper，另⼀种是类名中含有Decorator。动态代理:切⾯在应⽤运⾏的时刻被织⼊，⼀般情况下，在织⼊切⾯时，AOP容器会为⽬标对象创建动态的创建⼀个代理对象，Spring就是这样织⼊切⾯的。观察者模式:Spring的事件驱动模型使⽤的是观察者模式，Spring中Observer模式常⽤的地⽅是Listener的实现。策略模式:Spring框架的资源访问Resource接⼝。该接⼝提供了更强的资源访问能⼒Spring框架本身⼤量使⽤了Resource 接⼝来访问底层资源。模板⽅法:⽗类定义了骨架(调⽤哪些⽅法及顺序)，某些特定⽅法由⼦类实现refresh⽅法。
Spring MVC请求流程,⽤户发送请求到前端控制器DispatcherServlet；DispatcherServlet收到请求调⽤HandlerMapping处理映射器，处理映射器根据请求URI找到具体的处理器⽣成处理器和处理器拦截器并且返回给DispatcherServlet；DispatcherServlet调⽤HandlerAdapter处理器适配器；HandlerAdapter经过适配器调⽤具体的⻚⾯控制器(Controller)，⻚⾯控制器(Controller)执⾏完返回ModelAndView；HandlerAdapter将ModelAndView返回给DispatcherServlet；DispatcherServlet将ModelAndView传给ViewResolver视图解析器，ViewResolver解析后返回给具体的View；DispatcherServlet根据View进⾏渲染视图也就是将模型数据填充到视图中；DispatcherServlet响应⽤户。
Spring Boot常⽤注解,@SpringBootApplication这个注解标识了⼀个SpringBoot⼯程，它实际上是另外三个注解的组合；@SpringBootConfiguration这个注解实际就是⼀个@Configuration，表示启动类也是⼀个配置类；@EnableAutoConfiguration向Spring容器中导⼊⼀个Selector⽤来加载classpath下spring.factories中定义的⾃动配置类，将这些⾃动加载为配置Bean；@ComponentScan表示扫描路径，因为默认是没有配置实际扫描路径的，所以SpringBott扫描的路径是启动类所在的当前⽬录；@Bean⽤来定义Bean，类似于XML中<bean>，Spring在启动的时候会对这些@Bean注解的方法进⾏解析，将⽅法的名字作为beanName，并通过执⾏⽅法得到Bean对象。
SpringBoot是如何启动Tomcat的,⾸先SpringBoot在启动时会先创建⼀个Spring容器；在创建Spring容器过程中，会利⽤@ConditionalOnClass技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会⽣成⼀个启动Tomcat的Bean；Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端⼝等，然后启动Tomcat。
Spring Cloud核⼼组件以及作⽤,Eureka: 注册中⼼Nacos: 注册中⼼、配置中⼼Consul: 注册中⼼、配置中⼼Spring Cloud Config: 配置中⼼Feign/OpenFeign: RPC调⽤Kong: 服务⽹关Zuul: 服务⽹关Spring Cloud Gateway: 服务⽹关Ribbon: 负载均衡Spring Cloud Sleuth: 链路追踪Zipkin: 链路追踪Seata: 分布式事务Dubbo: RPC调⽤Sentinel: 服务熔断Hystrix: 服务熔断
Eureka的数据同步原理,Eureka是⼀个服务注册中⼼，对于集群之间的数据同步，采⽤对等复制的⽅式，也就是不存在主从之分，任何⼀个节点都可以接收和写⼊，⼀旦有⼀个节点数据发⽣变更，就会直接同步到其他节点上；Eureka这种⽆中⼼化节点的数据同步，需要考虑数据同步死循环的问题，也就是需要区分数据来源(属于客户端传来的数据还是集群中其他节点发来的同步数据)，Eureka通过时间戳的标记来区分；Eureka从数据同步上来看采⽤AP机制，对数据不提供强⼀致性保障。
谈⼀下分布式事务,本地事务就是对于操作单⼀数据库的场景下的事务，ACIO特性是数据库直接⽀持的。分布式事务就是在分布式环境下，需要保证不同服务的数据⼀致性，⼀般⽤于跨库事务、跨服务调⽤。分布式事务的实现⽅式：基于2PC两阶段提交：准备阶段，协调者通知参与者准备提交各⾃的事务；提交阶段，参与者反馈，协调者通过反馈去决定执⾏事务提交或回滚。基于3PC三阶段提交：3PC提交建⽴在2PC提交的基础上，将准备阶段拆分两步并且引⼊超时机制，询问阶段，协调者向参与者询问是否都能提交；预提交阶段，参与者能提交就先提交并且向协调者反馈，如果不能就放弃；提交阶段，协调者处理最终事务提交。分布式事务存在的问题：在准备阶段会出现同步阻塞，第⼀时间收到通知的服务会锁定资源，直到提交才会释放；容易出现单点故障，协调者⼀旦挂了，参与者都会阻塞，提别是提交阶段；可能造成数据不⼀致，如果提交阶段出现问题，可能导致⼀部分参与者的数据不⼀致。对于分布式事务，在实际⽣产中可以异常落表定时⾃动巡检、基于RocketMQ事务消息、基于Seata：异常落表定时⾃动巡检，当分布式事务执⾏失败时，将失败的信息记录到⼀张特殊的表中，然后通过定时任务去巡检这张表，对失败的事务进⾏重试或其他补偿操作；基于RocketMQ事务消息，RocketMQ⽀持事务消息，先发送⼀条半事务的消息，待本地事务执⾏成功后再提交这条消息，如果失败则回滚；基于Seata，Seata⽀持多种2PC模式。
谈谈对Seata的理解,Seata是⽤于处理分布式事务的解决⽅案，提供了AT、TCC、SAGA和XA事务模式，AT模式⾸推。AT模式的核⼼是对业务⽆侵⼊的：第⼀阶段，会将业务数据以及undo⽇志(回滚⽇志)进⾏本地事务提交，释放本地锁以及连接；第⼆阶段，如果提交，会将undo⽇志删除，如果回滚，会通过undo⽇志反向解析SQL语句进⾏回滚。XA模式是⼀个强⼀致性的2PC模式：每个分⽀的事务必须都完成之后，才进⾏提交。TCC模式对业务有侵⼊性的2PC模式：每个分⽀的事务都需要具备⾃⼰的两阶段，适⽤于复杂业务场景，try阶段⽤于进⾏业务的检查，预留必要的业务资源，confirm阶段⽤于具体业务的实现，cancel阶段⽤于事务执⾏失败之后，释放try阶段预留的资源。SAGA模式是基于状态机引擎的2PC模式：将⻓事务拆分为多个本地⼦事务以及相应的补偿操作来保证数据⼀致性。
