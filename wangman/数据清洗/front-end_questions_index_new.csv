index,content
为什么要实现HTML语义化？,易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页。有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。
什么是CSS盒模型？,盒模型是用于描述网页中元素布局的一个重要概念。它指的是每个 HTML 元素在页面上都被视为一个矩形的盒子，这个盒子包括了元素的内容（content）、内边距（padding）、边框（border）和外边距（margin）。这些部分组成了元素的整体尺寸和定位。
为什么会出现盒子塌陷？,当父元素没设置足够大小的时候，而子元素设置了浮动的属性，子元素就会跳出父元素的边界（脱离文档流），尤其是当父元素的高度为auto时，而父元素中又没有其它非浮动的可见元素时，父盒子的高度就会直接塌陷为零， 我们称这是CSS高度塌陷。
解释一下JavaScript中变量声明方式,var：在变量未赋值时，变量undefined（为使用声明变量时也为undefined）var的作用域为方法作用域，只要在方法内定义了，整个方法内的定义变量后的代码都可以使用。let：在变量为声明前直接使用会报错let为块作用域通常let比var 范围要小let禁止重复声明变量，否则会报错；var可以重复声明。const：const 声明创建一个只读的常量。一旦被赋值，常量的值就不能被修改。和let一样，const 声明也受限于块级作用域。常量的命名规则与变量相同，但通常使用全大写字母。
JavaScript中数据类型以及它们之间的区别,基本数据类型：Number，String，Boolean，null，undefined，symbol，bigint（后两个为ES6新增）引用数据类型：object，function（proto Function.prototype）object：普通对象，数组对象，正则对象，日期对象，Math数学函数对象。两种数据存储方式：基本数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用的数据。栈是存储基 本类型值和执行代码的空间。引用数据类型是存储在堆内存中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆 中该实体的起始地址，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆中获得实体。两种数据类型的区别：堆比栈空间大，栈比堆运行速度快。堆内存是无序存储，可以根据引用直接获取。基础数据类型比较稳定，而且相对来说占用的内存小。引用数据类型大小是动态的，而且是无限的。
对constructor的理解,创建的每个函数都有一个prototype（原型）对象，这个属性是一个指针，指向一个对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（继承自构造函数的prototype），指向构造函数的原型对象。注意当将构造函数的prototype设置为等于一个以对象字面量形式创建的新对象时，constructor属性不再指向该构造函数。
map和forEach的区别,相同点：都是循环遍历数组中的每一项每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）匿名函数中的this都是指向window只能遍历数组不同点：map()会分配内存空间存储新数组并返回，forEach()不会返回数据。forEach()允许callback更改原始数组的元素。map()返回新的数组。
JavaScript内存泄露的几种情况,意外的全局变量；闭包；未被清空的定时器；未被销毁的事件监听；DOM 引用；
promise和async await 区别,Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大，简单地说，Promise好比容器，里面存放着一些未来才会执行完毕（异步）的事件的结果，而这些结果一旦生成是无法改变的。async await也是异步编程的一种解决方案，他遵循的是Generator 函数的语法糖，他拥有内置执行器，不需要额外的调用直接会自动执行并输出结果，它返回的是一个Promise对象。两者的区别：Promise的出现解决了传统callback函数导致的“地域回调”问题，但它的语法导致了它向纵向发展行成了一个回调链，遇到复杂的业务场景，这样的语法显然也是不美观的。而async await代码看起来会简洁些，使得异步代码看起来像同步代码，await的本质是可以提供等同于”同步效果“的等待异步返回能力的语法糖，只有这一句代码执行完，才会执行下一句。async await与Promise一样，是非阻塞的。async await是基于Promise实现的，可以说是改良版的Promise，它不能用于普通的回调函数。
defer和async区别,使用 defer 时，脚本的执行会延迟到文档解析完毕之后，按照顺序执行。使用 async 时，脚本会在加载完成后立即执行，不会影响文档解析和其他资源的加载。
call appy bind的作用和区别,作用：都可以改变函数内部的this指向。区别点：call 和 apply 会调用函数，并且改变函数内部this指向。call 和 apply 传递的参数不一样，call 传递参数arg1，arg2...形式 apply 必须数组形式[arg]bind 不会调用函数，可以改变函数内部this指向。
JavaScript继承的方法和优缺点,原型链继承实现方式：将子类的原型链指向父类的对象实例原理：子类实例child的__proto__指向Child的原型链prototype，而Child.prototype指向Parent类的对象实例，该父类对象实例的__proto__指向Parent.prototype，所以Child可继承Parent的构造函数属性、方法和原型链属性、方法优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性缺点：无法向父类构造函数传参；且所有实例共享父类实例的属性，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；构造函数继承实现方式：在子类构造函数中使用call或者apply劫持父类构造函数方法，并传入参数原理：使用call或者apply更改子类函数的作用域，使this执行父类构造函数，子类因此可以继承父类共有属性优点：可解决原型链继承的缺点缺点：不可继承父类的原型链方法，构造函数不可复用组合继承原理：综合使用构造函数继承和原型链继承优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的缺点：会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数原型式继承原理：类似Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象缺点：共享引用类型寄生式继承原理：二次封装原型式继承，并拓展优点：可添加新的属性和方法寄生组合式继承原理：改进组合继承，利用寄生式继承的思想继承原型
为什么JavaScript是单线程的,这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
宏、微队列及执行顺序,宏列队：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调微列队：用来保存待执行的微任务（回调），比如：promise的回调、MutationObserver 的回调JS 执行时会区别这 2 个队列，JS 引擎首先必须先执行所有的初始化同步任务代码，每次准备取出第一个宏任务执行前， 都要将所有的微任务一个一个取出来执行，也就是优先级比宏任务高，且与微任务所处的代码位置无关。
什么是死锁,死锁是指两个或两个以上的进程在执行过程中，由于竞争资源而造成阻塞的现象，若无外力作用，它们都将无法继续执行。
产生死锁的必要条件,互斥条件（Mutual Exclusion）：至少有一个资源必须处于非共享模式，即一次只能被一个进程使用。如果一个进程在使用某资源时，其他进程无法同时使用该资源，就称为互斥条件。请求和保持条件（Hold and Wait）：进程至少在持有一个资源的同时，还在等待获取其他进程占有的资源。换句话说，进程在请求新的资源时不释放已经占有的资源。不剥夺条件（No Preemption）：进程已经获取的资源不能被强行剥夺，只能在进程使用完自己所拥有的资源之后自行释放。这意味着只能由持有资源的进程自己释放资源，而不能被其他进程强行夺走。环路等待条件（Circular Wait）：存在一个进程等待序列，使得每个进程都在等待下一个进程所占有的资源，形成一个环路。换句话说，每个进程都在等待下一个进程所持有的资源，直到最后一个进程等待第一个进程所占有的资源，从而形成了一个环路。
暂时性死区,暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
使用setInterval请求实时数据，返回顺序不一致怎么解决,"使用setTimeout代替setInterval程序首先设置10秒后发起请求，当数据返回后再隔10秒发起第二次请求，以此类推。这样的话虽然无法保证两次请求之间的时间间隔为固定值，但是可以保证到达数据的顺序。WebSocketWebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息""Upgrade: WebSocket""表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。"
防抖和节流的原理和使用场景,防抖（Debouncing）和节流（Throttling）都是用来控制事件触发频率的技术，它们的原理和使用场景略有不同。防抖（Debouncing）：原理：在一段连续的事件触发后，只有在某个延迟时间过去后，才执行事件处理函数。如果在这个延迟时间内又有新的事件触发，则重新计时。使用场景：（1）用户输入框实时搜索：用户连续输入时，不会立即触发搜索请求，而是等待一段时间，等用户输入停止后再发送请求，避免频繁的请求。（2）按钮点击事件：例如防止用户连续点击提交按钮多次触发提交操作，只有在一段时间内没有再次点击时才执行提交操作。节流（Throttling）：原理：限制事件的触发频率，确保连续触发的事件在一定时间间隔内只执行一次。与防抖不同的是，节流会按照固定的时间间隔执行事件处理函数。使用场景：（1）页面滚动事件：在页面滚动时，如果需要执行某些操作（如动态加载更多内容），可以使用节流来限制滚动事件的触发频率，避免性能问题。（2）鼠标移动事件：例如拖拽操作时，限制拖拽过程中触发的鼠标移动事件的频率，提高性能并减少不必要的计算。区别：（1）执行时机不同：防抖在事件连续触发后等待一段时间再执行，而节流在固定时间间隔内执行事件处理函数。（2）事件频率控制方式不同：防抖是等待一段时间后执行最后一次触发的事件，节流是按照固定的时间间隔执行事件处理函数。
浅拷贝与深拷贝,浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制。
闭包的理解,一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围）， 这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。闭包的特点：让外部访问函数内部变量成为可能；可以避免使用全局变量，防止全局变量污染；可以让局部变量常驻在内存中；会造成内存泄漏（有一块内存空间被长期占用，而不被释放）
Cookie、SessionStorage、localStorage 区别,共同点：都是保存在浏览器端、且同源的区别：（1）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下（2）存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大（3）数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭（4）作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的（5）web Storage支持事件通知机制，可以将数据更新的通知发送给监听者（6）web Storage的api接口使用更方便
如何写一个会过期的localStorage，说说你的想法,惰性删除：某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。定时删除：每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。另一方面定时删除也有效的减少了因惰性删除带来的对localStorage空间的浪费。
localStorage可以跨域吗,不能，以下给出解决方案：通过postMessage来实现跨源通信可以实现一个公共的iframe部署在某个域名中，作为共享域将需要实现localStorage跨域通信的页面嵌入这个iframe接入对应的SDK操作共享域，从而实现localStorage的跨域存储
前端性能优化手段,加载优化: 减少HTTP请求、缓存资源、压缩代码、无阻塞、首屏加载、按需加载、预加载、压缩图像、减少Cookie、避免重定向、异步加载第三方资源执行优化：CSS写在头部，JS写在尾部并异步、避免img、iframe等的src为空、尽量避免重置图像大小、图像尽量避免使用DataURL渲染优化：设置viewport、减少DOM节点、优化动画、优化高频事件、GPU加速样式优化：避免在HTML中书写style、避免CSS表达式、移除CSS空规则、正确使用display：display、不滥用float等脚本优化：减少重绘和回流、缓存DOM选择与计算、缓存.length的值、尽量使用事件代理、尽量使用id选择器、touch事件优化
什么是尾调用优化,尾调用是指某个函数的最后一步是调用另一个函数。函数调用会在内存形成一个“调用记录”，又称“调用帧”，保存调用位置和内存变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，依次类推。所有的调用帧，就形成一个“调用栈”。尾调用由于是函数的最后一步操作，所有不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。
解释一下XSS和CSRF,XSS（Cross-site scripting），指的是跨站脚本攻击，攻击者通过向页面A注入代码，达到窃取信息等目的，本质是数据被当作程序执行。XSS危害是很大的，一般XSS可以做到以下的事情：获取页面的数据，包括dom、cookies、localStorage等；劫持前端逻辑；发送请求。CSRF(Cross Site Request Frogy)指的是跨站请求伪造。与XSS不同的是，XSS是攻击者直接对我们的网站A进行注入攻击，CSRF是通过网站B对我们的网站A进行伪造请求。
 jsonp原理,利用<script>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定 需要对方的服务器做支持才可以。
有什么方法可以保持前后端实时通信,（1）WebSocket： IE10以上才支持，Chrome16， FireFox11，Safari7以及Opera12以上完全支持，移动端形势大（2）event-source: IE完全不支持（注意是任何版本都不支持），Edge76，Chrome6，Firefox6，Safari5和Opera以上支持， 移动端形势大好（3）AJAX轮询： 用于兼容低版本的浏览器（4）永久帧（ forever iframe）可用于兼容低版本的浏览器（5）flash socket：可用于兼容低版本的浏览器
HTTP和HTTPS的基本概念,HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
HTTP与HTTPS有什么区别？,HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTPS和HTTP的区别主要如下：1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
http请求方式,http请求方式有以下8种，其中get和post是最常用的：1、OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性2、HEAD向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。3、GET向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url4、POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data，web_submit_form5、PUT向指定资源位置上传其最新内容6、DELETE请求服务器删除Request-URL所标识的资源7、TRACE回显服务器收到的请求，主要用于测试或诊断8、CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
非对称加密和对称加密，具体怎么实现的,对称加密：在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的。也就是说，加密和解密都是使用的同一个密钥。非对称加密：指加密和解密使用不同密钥的加密算法。非对称加密算法需要两个密钥：公钥（publickey）私钥（privatekey）。公钥与私钥是一对存在，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用密钥对数据进行加密，那么只有用对应的公钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
什么是数字证书,数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。数字证书绑定了公钥及其持有者的真实身份，它类似于现实生活中的居民身份证，所不同的是数字证书不再是纸质的证照，而是一段含有证书持有者身份信息并经过认证中心审核签发的电子数据，广泛用在电子商务和移动互联网中。
什么是数字签名,数字签名是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改；否则说明信息被修改过，因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。数字签名是个加密的过程，数字签名验证是个解密的过程。数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。
非对称加密和对称加密在HTTPS协议中的应用,（1）浏览器向服务器发出请求，询问对方支持的对称加密算法和非对称加密算法；服务器回应自己支持的算法。（2） 浏览器选择双方都支持的加密算法，并请求服务器出示自己的证书；服务器回应自己的证书。（3）浏览器随机产生一个用于本次会话的对称加密的钥匙，并使用服务器证书中附带的公钥对该钥匙进行加密后传递给服务器；服务器为本次会话保持该对称加密的钥匙。第三方不知道服务器的私钥，即使截获了数据也无法解密。非对称加密让任何浏览器都可以与服务器进行加密会话。（4） 浏览器使用对称加密的钥匙对请求消息加密后传送给服务器，服务器使用该对称加密的钥匙进行解密；服务器使用对称加密的钥匙对响应消息加密后传送给浏览器，浏览器使用该对称加密的钥匙进行解密。第三方不知道对称加密的钥匙，即使截获了数据也无法解密。对称加密提高了加密速度。
 讲一下Ajax原理以及为什么要用Ajax,Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎)，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器，像—些数据验证和数据处理等都交给Ajax引擎自己来做， 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。Ajax是一种异步请求数据的web开发技术，对于改善用户的体验和页面性能很有帮助。简单地说，在不需要重新刷新页面的情况下，Ajax通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax的目的是提高用户体验，较少网络数据的传输量。同时，由于Ajax请求获取的是数据而不是HTML文档，因此它也节省了网络带宽，让互联网用户的网络冲浪体验变得更加顺畅。
什么是同源策略，为什么需要同源策略,同源策略(Same Origin Policy)是一种约定，它是浏览器最核心最基本的安全功能。所谓的同源是指域名、协议、端口相同。不同源的客户端脚本在没有明确授权的情况下是不允许读写其他网站的资源。同源策略的限制:Cookie、LocalStorage 和 IndexDB 无法读取。DOM 无法获得。AJAX 请求不能发送。同源策略作用:防止恶意网页可以获取其他网站的本地数据。防止恶意网站iframe其他网站的时候，获取数据.防止恶意网站在自已网站有访问其他网站的权利，以免通过cookie免登，拿到数据。
TCP三次握手为什么需要三次,两个目的：确保建立可靠连接；避免资源浪费三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。
TCP vs UDP,TCP(传输控制协议)和UDP（用户数据报协议）：TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。UDP（用户数据报协议）是iso参考模型中一种无连接的传输层协议，提供简单不可靠的非连接传输层服务，面向报文区别：（1）TCP是面向连接的，可靠性高；UDP是基于非连接的，可靠性低（2）由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP没有建立连接的过程，因而实时性较强，也稍安全（3）在传输相同大小的数据时，TCP首部开销20字节；UDP首部开销8字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，而UDP有丢包，故TCP开销大，UDP开销较小（4）每条TCP连接只能时点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信应用场景选择：（1）对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP（2）需要传输大量数据且对可靠性要求高的情况下使用TCP	
301和302的含义,301和302都是重定向的状态码，重定向（Redirect）是指通过各种方法将客户端的网络请求重新定义或指定一个新方向转到其他位置（重定向包括网页重定向、域名重定向）。301 redirect: 301 代表永久性转移(Permanently Moved)302 redirect: 302 代表暂时性转移(Temporarily Moved )相同点：都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）不同点：（1）301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；（2）302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。（3）302会出现“网址劫持”现象，从A网址302重定向到B网址，由于部分搜索引擎无法总是抓取到目标网址，或者B网址对用户展示不够友好，因此浏览器会仍旧显示A网址，但是所用的网页内容却是B网址上的内容。应用场景：301：域名需要切换、协议从http变成https；302：未登录时访问已登录页时跳转到登录页面、404后跳转首页
DNS是什么,DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。
介绍下 HTTPS 中间人攻击,https 协议由 http + ssl 协议构成。中间人攻击过程如下：服务器向客户端发送公钥；攻击者截获公钥，保留在自己手上；然后攻击者自己生成一个【伪造的】公钥，发给客户端；客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器；攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥；同时生成假的加密 hash 值，发给服务器；服务器用私钥解密获得假秘钥；服务器用假秘钥加密传输信息；防范方法：服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（现有 HTTPS 很难被劫持，除非信任了劫持者的 CA 证书）。
CDN加速原理,（1）当用户点击网站页面上的URL时，经过本地DNS系统解析，DNS系统会将域名的解析权给交CNAME指向的CDN专用DNS服务器。（2）CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。（3）用户向CDN的全局负载均衡设备发起内容URL访问请求。（4）CDN全局负载均衡设备根据用户IP，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备（5）区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址全局负载均衡设备把服务器的IP地址返回给用户。（6）用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器 就要向它的上一级缓存服务器发起请求内容，直至追溯到网站的源服务器将内容拉回给用户。
请介绍一下 Node 中的内存泄露问题和解决方案,内存泄露原因全局变量：全局变量挂在 root 对象上，不会被清除掉；闭包：如果闭包未释放，就会导致内存泄露；事件监听：对同一个事件重复监听，忘记移除（removeListener），将造成内存泄露。解决方案:最容易出现也是最难排查的就是事件监听造成的内存泄露，所以事件监听这块需要格外注意小心使用。如果出现了内存泄露问题，需要检测内存使用情况，对内存泄露的位置进行定位，然后对对应的内存泄露代码进行修复。
什么是守护进程？Node 如何实现守护进程？,守护进程是不依赖终端（tty）的进程，不会因为用户退出终端而停止运行的进程。Node 实现守护进程的思路：创建一个进程 A；在进程 A 中创建进程 B，可以使用child_process.fork或者其他方法；启动子进程时，设置detached属性为 true，保证子进程在父进程退出后继续运行；进程 A 退出，进程 B 由 init 进程接管。此时进程 B 为守护进程。
设计模式有哪些,设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。单体模式：单体是一个用来划分命名空间并将一批相关的属性和方法组织在一起的对象，如果他可以被实例化，那么他只能被实例化一次。工厂模式:提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）单例模式：单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。观察者模式（发布订阅模式）：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新，也被称为是发布订阅模式。策略模式：策略模式指的是定义一些列的算法，把他们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。说白了就是以前要很多判断的写法，现在把判断里面的内容抽离开来，变成一个个小的个体模板模式：定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 通俗的讲，就是将一些公共方法封装到父类，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑代理模式：代理模式的中文含义就是帮别人做事，javascript的解释为：把对一个对象的访问， 交给另一个代理对象来操作外观模式： 外观模式是很常见。其实它就是通过编写一个单独的函数，来简化对一个或多个更大型的，可能更为复杂的函数的访问。也就是说可以视外观模式为一种简化某些内容的手段
说一下归并排序思想怎么实现的,“归并”的意思是将两个或两个以上的有序表组合成一个新的有序表。假如初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到[n/2]（向上取整）个长度为2或1的有序子序列；再两两归并，……，如此重复，直到得到一个长度为n的有序序列为止，这种排序方法称为2-路归并排序。步骤解析：1、把长度为n的输入序列分成两个长度为n/2的子序列；2、对这两个子序列继续分为m/2的子序列，一直分下去，直为1个元素；3、将两个排序好的子序列合并成一个最终的排序序列。特点：速度仅次于快速排序，为稳定排序算法，一般用于总体无序，但是各子项相对有序的数列，属于分治思想，递归归并。
v-model 作用？,v-model本质上不过是语法糖，可以用 v-model 指令在表单及元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素；它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理；v-model会忽略所有表单元素的value、checked、selected特性的初始值，而总是将 Vue 实例的数据作为数据来源，因此我们应该通过 JavaScript 在组件的data选项中声明初始值。
什么是导航守卫,导航守卫主要用来通过跳转或取消的方式守卫导航。简单的说，导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他事的时机，这就是导航守卫。
双向数据绑定,双向数据绑定是一种编程模式，用于在用户界面（UI）元素和数据模型之间建立实时的、双向的关联关系。在这种模式下，当数据模型发生变化时，UI元素会自动更新以反映这些变化；反之，当用户在UI元素上进行操作（比如输入、选择等），相应的数据模型也会随之更新。这种模式的实现通常需要借助特定的框架或库来提供支持。常见的前端框架，如Angular、Vue.js和React，都提供了双向数据绑定的功能。在这些框架中，开发者只需关注数据的处理和展示，而不必手动编写大量的DOM操作代码。
 JavaScript是如何监听HistoryRouter的变化的,通过浏览器的地址栏来改变切换页面，前端实现主要有两种方式：（1）通过hash改变，利用window.onhashchange 监听。（2）HistoryRouter：通过history的改变，进行js操作加载页面，然而history并不像hash那样简单，因为history的改变，除了浏览器的几个前进后退（使用 history.back()， history.forward()和 history.go() 方法来完成在用户历史记录中向后和向前的跳转。）等操作会主动触发popstate 事件，pushState，replaceState 并不会触发popstate事件，要解决history监听的问题，方法是：首先完成一个订阅-发布模式，然后重写history.pushState， history.replaceState，并添加消息通知，这样一来只要history的无法实现监听函数就被我们加上了事件通知，只不过这里用的不是浏览器原生事件，而是通过我们创建的event-bus 来实现通知，然后触发事件订阅函数的执行。
虚拟dom是什么？,虚拟DOM（Virtual DOM）是前端开发中常用的一种技术概念，主要用于优化页面渲染性能，并简化开发复杂度。虚拟DOM是对真实DOM的一种抽象表示，在内存中以树形结构存在，用于描述页面的结构和状态。工作原理：初始化阶段：当页面加载时，浏览器会解析HTML代码并生成真实DOM树。更新阶段：当页面状态发生变化（比如数据变化或用户交互），通常会触发重新渲染。此时，框架会通过比较新旧状态生成一棵虚拟DOM树。Diff算法：虚拟DOM通过Diff算法对比新旧虚拟DOM树的差异，找出需要更新的部分。更新真实DOM：框架根据Diff算法的结果，只更新真实DOM中需要变更的部分，而不是整体重新渲染页面。优势：性能优化：由于真实DOM操作比较昂贵，通过虚拟DOM可以减少实际DOM操作次数，提高页面渲染性能。跨平台开发：虚拟DOM的抽象性质使得可以在不同平台（比如浏览器、移动端原生应用）上进行开发，实现代码复用。简化开发：开发者可以专注于数据和视图的关系，而不必过多关注DOM操作细节，提高开发效率和代码可维护性。批量更新：虚拟DOM可以对多次数据变更进行批量处理，最终只进行一次DOM更新，减少性能损耗。
setState到底是异步还是同步?,有时表现出异步，有时表现出同步（1）setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步的。（2）setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数setState(partialState， callback)中的callback拿到更新后的结果。（3）setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。
state和props区别是什么？,props和state是普通的js对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即：（1）state 是组件自己管理数据，控制自己的状态，可变；（2）props 是外部传入的数据参数，不可变；（3）没有state的叫做无状态组件，有state的叫做有状态组件；（4）多用 props，少用 state，也就是多写无状态组件。
MVC和MVVM的区别,MVC: MVC是应用最广泛的软件架构之一，一般MVC分为:Model(模型)，View(视图)，Controller(控制器)。 这主要是基于分层的目的，让彼此的职责分开.View一般用过Controller来和Model进行联系。Controller是Model和View的协调者，View和Model不直接联系。基本都是单向联系。MVVM:MVVM是把MVC中的Controller改变成了ViewModel。View的变化会自动更新到ViewModel，ViewModel的变化也会自动同步到View上显示，通过数据来显示视图层。MVVM和MVC的区别:（1）MVC中Controller演变成MVVM中的ViewModel（2）MVVM通过数据来显示视图层而不是节点操作（3）MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低，加载速度变慢，影响用户体验
Webpack的打包流程,Webpack的运行流程是一个串行的过程，从启动到结束依次执行以下流程：初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。
